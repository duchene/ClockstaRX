\name{clock.space}
\alias{clock.space}
\title{
clock.space
}
\description{
clock.space takes in the output from the function collect.rates.
}
\usage{
clock.space(ratesmat, sptr, N.imputations, prop.sample.for.imputation, mean.scaling.brlen, ncore, make.plot)
}
\arguments{
  \item{ratesmat}{
A list as generated by the function collect.rates, containing the raw branch lengths collected from loci trees, and a vector of the number of loci that contain each of the branches of the species tree.
}
  \item{sptr}{
A phylogenetic tree of class 'phylo'.
}
  \item{N.imputations}{
A numeric value representing the number of replicate imputed data sets to generate. This argument is not needed unless using the function mice, which is not currently the case.
}
  \item{prop.sample.for.imputation}{
A numeric value representing the proportion of the loci to be used to impute the rates for each of the branch lengths. This argument is not needed unless using the function mice, which is not currently the case.
}
  \item{mean.scaling.brlen}{
A numeric value of the mean branch length to assume when making comparisons ammong gene trees. This can be an arbitrary value and is primarily for the purpose of comparing pairs of trees.
}
  \item{ncore}{
A numeric value of the number of computer cores to be used for calculating the bsd matrix.
}
  \item{make.plot}{
A locical (T/F) defining whether to make a plot of each of the three rates spaces (raw, relative bsd, and residual bsd).
}
}
\details{
The function plots...
}
\value{
A list with two items:
  \item{roottotippath }{A vector with the distance from the root to the tips. If tipsonly==F, it will also include the distances for internal nodes.}
  \item{nodesinpath }{A vector with the number of nodes along a lineage. If tipsonly==F, it will also include the number of nodes for internal nodes. These are counted from the tips to the root.}
}
\references{
Venditti, Chris, Andrew Meade, and Mark Pagel. "Detecting the node-density artifact in phylogeny reconstruction." Systematic biology 55.4 (2006): 637-643.
 
}
\author{
David Duchene
}
\note{
Please see the references for more detailed information.
}

\seealso{
Pending.
}
\examples{
set.seed(12345)
myTree <- rtree(10)

par(mfrow = c(1, 2))
plot(myTree)
nde <- pathnode(myTree)
nde



## The function is currently defined as
function (phylo, tipsonly = T) 
{
    require(phangorn)
    di.tr <- dist.nodes(phylo)
    root.tr <- phylo$edge[, 1][!(phylo$edge[, 1] \%in\% phylo$edge[, 
        2])][1]
    tr.depth <- max(di.tr[as.numeric(colnames(di.tr)) == root.tr, 
        ])
    if (tipsonly == TRUE) {
        roottotippath <- di.tr[as.numeric(rownames(di.tr)) == 
            root.tr, 1:length(phylo$tip.label)]
        nodesinpath <- sapply(1:length(phylo$tip.label), function(x) length(Ancestors(phylo, 
            x)))
    }
    else {
        roottotippath <- di.tr[as.numeric(rownames(di.tr)) == 
            root.tr, ]
	nodesinpath <- sapply(1:(length(phylo$tip.label)+phylo$Nnode), function(x) length(Ancestors(phylo, x)))
    }
    plot(roottotippath, nodesinpath, xlab = "Root-to-tip path length", 
        ylab = "Number of parent nodes", pch = 20)
    return(list(roottotippath = roottotippath, nodesinpath = nodesinpath))
  }
}
\keyword{ Node-density-effect }